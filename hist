#!/usr/bin/env bash

VERSION="0.0.2"
HISTORIAN_SRC=${HISTORIAN_SRC-"${HOME}/.bash_history"}
HISTORIAN_DB=${HISTORIAN_DB-"${HOME}/.historian.db"}
HISTORIAN_SQLITE3=${HISTORIAN_SQLITE3-"$(which sqlite3)"}
MAGIC="$(echo -e "\x10\x83\xB9\x9F\x34\xB5\x96\x45")" # 0118 999 881 999 119 725 3
MAGIC_ENUM_QUOTE=1

SEPARATOR=$(echo -e "\x01")

# Other ENV parameters:
#
# - ZSH_EXTENDED_HISTORY: if set, parses HISTORIAN_SRC using zsh's
#   EXTENDED_HISTORY format

usage() {
    echo "Usage: hist <subcommand>" >&2
    echo "subcommands:" >&2
    echo "  config           show config" >&2
    echo "  count            count items in history" >&2
    echo "  import           import to db" >&2
    echo "  shell            launch sqlite3 shell with db" >&2
    echo "  search <term>    search for <term>" >&2
    echo "    /term          search for <term>" >&2
    echo "  version          show the version" >&2
}

sql_quote_term() {
    echo "${*//\'/\'\'}"
}

historian_sqlite() {
    # Attempt to normalize sqlite options in case there is
    # some sqliterc imposing global defaults.
    "${HISTORIAN_SQLITE3}" "${HISTORIAN_DB}"
}

preflight_check() {
    if [ -z "$HOME" ]; then
        echo "need \$HOME" >&2
        exit 1
    fi

    if [ -z "${HISTORIAN_SQLITE3}" ]; then
        echo "need sqlite3" >&2
        exit 1
    fi
}

ensure_db_exists() {
    historian_sqlite <<SQL
        CREATE TABLE IF NOT EXISTS history (
            id INTEGER PRIMARY KEY ASC,
            command TEXT NOT NULL,
            timestamp INTEGER
        );
        CREATE UNIQUE INDEX IF NOT EXISTS
            history_command_timestamp ON history(command);
        CREATE VIRTUAL TABLE IF NOT EXISTS
            history_search USING fts4(id, history, command);
SQL
}

get_magic() {
    local idx=$1
    let offset_idx=idx+11
    suffix=$(printf "%02d" ${offset_idx})
    echo -n "${MAGIC}$(echo -ne "\x${suffix}")"
}

fail_unless_db_exists() {
    if [ ! -f "${HISTORIAN_DB}" ]; then
        echo "db (${HISTORIAN_DB}) doesn't exist. Aborting";
        exit 1;
    fi
}

cmd_config() {
    echo "version:        ${VERSION}"
    echo "source_history: ${HISTORIAN_SRC}"
    echo "db:             ${HISTORIAN_DB}"
    echo "sqlite3:        ${HISTORIAN_SQLITE3}"
}

cmd_count() {
    local args=$@
    preflight_check;
    ensure_db_exists;

    historian_sqlite <<SQL
        SELECT COUNT(*) FROM history;
SQL
}

cmd_import() {
    local args=$@
    preflight_check;
    ensure_db_exists;

    sanitized_src=$(mktemp)
    cat ${HISTORIAN_SRC} \
        | sed -e 's/"/'$(get_magic ${MAGIC_ENUM_QUOTE})'/g' \
        > "${sanitized_src}" \
    ;
    if [ -n "${ZSH_EXTENDED_HISTORY}" ]; then
        _import_zsh_extended_history;
    else
        _import_default;
    fi
}

_import_default() {
    historian_sqlite <<SQL
        CREATE TEMPORARY TABLE variables
            (key TEXT, value INTEGER);
        INSERT INTO variables(key, value)
            SELECT 'items', COUNT(*) FROM history;
        CREATE TEMPORARY TABLE history_import (line TEXT);
.separator ${SEPARATOR}
.import ${sanitized_src} history_import
        UPDATE history_import
            SET line = REPLACE(line, '$(get_magic ${MAGIC_ENUM_QUOTE})', '"');
        INSERT OR IGNORE INTO history(command, timestamp)
            SELECT line, NULL FROM history_import;
        UPDATE variables
            SET value = -1 * value + (SELECT COUNT(*) FROM history); -- lol subtraction
        SELECT 'Imported ' || value || ' item(s).' FROM variables WHERE key = 'items';
SQL
    rm -f ${sanitized_src};
}

# http://zsh.sourceforge.net/Doc/Release/Options.html#History
_import_zsh_extended_history() {
    local tmpdir=$(mktemp -d)
    tmp_src=${tmpdir}/$(basename $HISTORIAN_SRC)
    sed -e 's/^: \([0-9][0-9]*\):\([0-9][0-9]*\);/\1'${SEPARATOR}'/g' ${HISTORIAN_SRC} \
        > ${tmp_src}
    historian_sqlite <<SQL
        CREATE TEMPORARY TABLE variables
            (key TEXT, value INTEGER);
        INSERT INTO variables(key, value)
            SELECT 'items', COUNT(*) FROM history;
        CREATE TEMPORARY TABLE history_import (timestamp INTEGER, command TEXT);
.separator ${SEPARATOR}
.import ${tmp_src} history_import
        INSERT OR IGNORE INTO history(timestamp, command)
            SELECT timestamp, command FROM history_import;
        UPDATE variables
            SET value = -1 * value + (SELECT COUNT(*) FROM history); -- lol subtraction
        SELECT 'Imported ' || value || ' item(s).' FROM variables WHERE key = 'items';
SQL
    [ -n "$tmpdir" ] && rm -rf $tmpdir
}

cmd_log() {
    local args=$@
    preflight_check;
    fail_unless_db_exists;

    historian_sqlite <<SQL | less
.separator "\\n\\t"
        SELECT id, command FROM history ORDER BY id DESC;
SQL
}

cmd_search() {
    preflight_check;
    ensure_db_exists;

    local -r args=("$@")
    search_terms() {
        for term in "${args[@]}"; do
            echo "AND command LIKE '%$(sql_quote_term "$term")%'"
        done
    }

    historian_sqlite <<SQL
.separator "\\n\\t"
        SELECT id, command
        FROM history
        WHERE 1
        $(search_terms)
        ORDER BY id DESC;
SQL
}

cmd_shell() {
    local args=$@
    preflight_check;
    fail_unless_db_exists;

    echo "${HISTORIAN_SQLITE3}" "${HISTORIAN_DB}" >&2
    historian_sqlite
}

cmd_version() {
    echo "historian version: ${VERSION}"
}

main() {
    local -r cmd=$1
    shift
    case $cmd in
    "" | "-h" | "--help")
        usage
        ;;
    /*)
        # Strip trailing slash and proceed normally.
        args=("${cmd:1}" $@)
        cmd_search "${args[@]}"
        ;;
    *)
        subcommand=cmd_${cmd}
        if typeset -rF "$subcommand"; then
            "$subcommand" "$@"
        else
            usage
            exit 1
        fi
        ;;
    esac
}

main $@
