#!/usr/bin/env bash

VERSION="0.0.2"
HISTORIAN_SRC=${HISTORIAN_SRC-"${HOME}/.bash_history"}
HISTORIAN_DB=${HISTORIAN_DB-"${HOME}/.historian.db"}
HISTORIAN_SQLITE3=${HISTORIAN_SQLITE3-"$(which sqlite3)"}

# Other ENV parameters:
#
# - ZSH_EXTENDED_HISTORY: if set, parses HISTORIAN_SRC using zsh's
#   EXTENDED_HISTORY format

usage() {
    echo "Usage: hist <subcommand>" >&2
    echo "subcommands:" >&2
    echo "  config           show config" >&2
    echo "  count            count items in history" >&2
    echo "  import           import to db" >&2
    echo "  shell            launch sqlite3 shell with db" >&2
    echo "  search <term>    search for <term>" >&2
    echo "    /term          search for <term>" >&2
    echo "  version          show the version" >&2
}

sql_quote_term() {
    echo "${*//\'/\'\'}"
}

historian_sqlite() {
    # Attempt to normalize sqlite options in case there is
    # some sqliterc imposing global defaults.
    "${HISTORIAN_SQLITE3}" "${HISTORIAN_DB}" \
        -noheader \
        -list \
        ;
}

preflight_check() {
    if [ -z "$HOME" ]; then
        echo "need \$HOME" >&2
        exit 1
    fi

    if [ -z "${HISTORIAN_SQLITE3}" ]; then
        echo "need sqlite3" >&2
        exit 1
    fi
}

ensure_db_exists() {
    historian_sqlite <<SQL
        CREATE TABLE IF NOT EXISTS history (
            id INTEGER PRIMARY KEY ASC,
            command TEXT NOT NULL,
            timestamp INTEGER
        );
        CREATE UNIQUE INDEX IF NOT EXISTS
            history_command_timestamp ON history(command);
        CREATE VIRTUAL TABLE IF NOT EXISTS
            history_search USING fts4(id, history, command);
SQL
}

fail_unless_db_exists() {
    if [ ! -f "${HISTORIAN_DB}" ]; then
        echo "db (${HISTORIAN_DB}) doesn't exist. Aborting";
        exit 1;
    fi
}

cmd_config() {
    echo "version:        ${VERSION}"
    echo "source_history: ${HISTORIAN_SRC}"
    echo "db:             ${HISTORIAN_DB}"
    echo "sqlite3:        ${HISTORIAN_SQLITE3}"
}

cmd_count() {
    preflight_check;
    ensure_db_exists;

    historian_sqlite <<SQL
        SELECT COUNT(*) FROM history;
SQL
}


csv_from_extended_zsh_history() {
    # See: http://zsh.sourceforge.net/Doc/Release/Options.html#History
    #
    # NB. It is not 100% possible to disambiguate zsh lines from each other.
    # This is because there can be any number of backslashes in the command history.
    #
    # However, in practice it is very unlikely for someone to construct
    # lines like the following for zsh history.
    # : 1234567890:0;whatever\
    # : 1234567890:0;whatever\\\\
    awk '
    function print_row() {
        cmd=""
        for (i=1; i<length(lines); ++i) {
          line = lines[i];
          # Strip trailing backslash, add newline.
          cmd = cmd substr(line, 1, length(line) - 1) RS
        }
        cmd = cmd lines[length(lines)]

        # Escape quotes:
        gsub("\"","\"\"", cmd);
        # CSV row of form "timestamp,command"
        print t ",\"" cmd "\"";
    }

    {
        if(match($0, /^: ([1-9][0-9]{8,9}):[0-9]+;(.*)$/, a)) {
            if (t && length(lines) > 0) { print_row(); }
            delete lines;
            t=a[1]; line=a[2];
        } else {
            line = $0;
        }
        lines[length(lines) + 1] = line;
    }

    END {
        if (t && length(lines) > 0) { print_row(); }
    }
    '
}

csv_from_bash_history() {
    # Test if the line looks like a timestamp (e.g. "#1234567890").
    #
    # Assume a timestamp is 9 or 10 digits long.
    # So we only accept entries made between 1973 and 2286.
    #
    # This is heuristic by necessity so we do this to try
    # minimize the number of false positives.
    #
    # This should be OK for even the earliest timestamped
    # readline history file :)
    #
    # This is way too slow if implemented in bash so I opted
    # to use awk instead.
    # Could be faster still but this is kind of adequate.
    #
    # NB. bash has a syntax-check-only mode "bash -n".
    # This would seem to be the correct option to use here
    # but even it won't work for everything bash actually
    # writes to history!
    #
    # For example, typing the following line in bash *will*
    # write it to history, BUT it won't be syntactically valid.
    #     { echo ' }
    #
    awk '
    function print_row(){
        # Escape quotes:
        gsub("\"","\"\"", cmd);
        # Remove spurious trailing newline
        sub(/.$/, "", cmd);
        # CSV row of form "timestamp,command"
        print t ",\"" cmd "\"";
    }

    # Match timestamp lines
    /^#[1-9][0-9]{8,9}$/ {
        # Print a CSV row IF there is a timestamp associated with it.
        if (t && cmd) { print_row() }
        # Remove leading "#" from timestamp:
        t=substr($0, 2);
        # No commands seen for this timestamp.
        cmd="";
        # Skip to next line.
        next;
    }
    {
        # Keep adding lines to our command-seen-so-far
        cmd=cmd $0 RS;
    }
    END {
        # Print any final line if one exists
        if (t && cmd) { print_row() }
    }
    '
}

csv_from_bash_history() {
    awk '{
    # Escape quotes:
    gsub("\"","\"\"", $0);
    # CSV row of form "timestamp,command" with zero timestamp.
    # NB. The timestamp cannot be null for the unique constraints
    # to work properly.
    print "0,\"" $0 "\"";
    }'
}

cmd_import() {
    preflight_check
    ensure_db_exists

    readonly tmp=$(mktemp -d)
    local -r history_csv_path=${tmp}/history.csv
    local -r import_sql=${tmp}/import.sql

    cleanup() { rm -rf "$tmp"; }
    trap cleanup EXIT

    if [[ -n $ZSH_EXTENDED_HISTORY ]]; then
        csv_from_extended_zsh_history \
            < "${HISTORIAN_SRC}" \
            > "${history_csv_path}"
    else
        csv_from_bash_history \
            < "${HISTORIAN_SRC}" \
            > "${history_csv_path}"
    fi

    cat > "$import_sql" <<- SQL
        CREATE TEMPORARY TABLE variables
            (key TEXT, value INTEGER);

        INSERT INTO variables(key, value)
        SELECT 'items', COUNT(*)
        FROM history;

        CREATE TEMPORARY TABLE history_import (
            command_timestamp INTEGER NOT NULL
            ,command TEXT NOT NULL
        );

.mode csv
.import "${history_csv_path}" history_import

        INSERT OR IGNORE INTO history (timestamp, command)
        SELECT
            CASE WHEN command_timestamp = 0
                THEN current_timestamp
                ELSE command_timestamp -- datetime(command_timestamp, 'unixepoch')
            END as command_timestamp
            , command
        FROM history_import;

.mode ascii
        SELECT 'Imported '
            || (SELECT COUNT(*) - value FROM history)
            || ' item(s).'
            FROM variables WHERE key = 'items';
SQL

    historian_sqlite < "$import_sql"
    echo
}

cmd_log() {
    preflight_check;
    fail_unless_db_exists;

    historian_sqlite <<SQL | less
.separator "\\n\\t"
        SELECT id, command FROM history ORDER BY id DESC;
SQL
}

cmd_search() {
    preflight_check;
    ensure_db_exists;

    local -r args=("$@")
    search_terms() {
        for term in "${args[@]}"; do
            echo "AND command LIKE '%$(sql_quote_term "$term")%'"
        done
    }

    historian_sqlite <<SQL
.separator "\\n\\t"
        SELECT id, command
        FROM history
        WHERE 1
        $(search_terms)
        ORDER BY id DESC;
SQL
}

cmd_shell() {
    preflight_check;
    fail_unless_db_exists;

    echo "${HISTORIAN_SQLITE3}" "${HISTORIAN_DB}" >&2
    historian_sqlite
}

cmd_version() {
    echo "historian version: ${VERSION}"
}

main() {
    local -r cmd=$1
    shift
    case $cmd in
    "" | "-h" | "--help")
        usage
        ;;
    /*)
        # Strip trailing slash and proceed normally.
        args=("${cmd:1}" $@)
        cmd_search "${args[@]}"
        ;;
    *)
        subcommand=cmd_${cmd}
        if typeset -rF "$subcommand"; then
            "$subcommand" "$@"
        else
            usage
            exit 1
        fi
        ;;
    esac
}

main "$@"
